# SymPy Cheat Sheet

# -------------------------------------------------------------------------
# Basic Math

Arithmetic:
  - addition           # a + b
  - subtraction        # a - b
  - multiplication     # a * b
  - raising to a power # a ** b
  - division           # a / b
  - floor division     # quotient = a // b
  - modulos            # remainder = a % b

Basic Math Functions:
  - square              # power(x, 2)
  - cube                # power(x, 3)
  - nth power           # power(x, n)
  - exponential         # exp(x)
  - natural logarithm   # log(x), ln(x)
  - logarithm with base # log(x, b)
  - square root         # sqrt(x)
  - cube root           # root(x, 3)
  - nth root            # root(x, n)
  - absolute value      # Abs(x)
  
Comparison Operators:
  - greater than             # a > b
  - less than                # a < b
  - greater than or equal to # a >= b
  - less than or equal to    # a <= b
  - structural equality      # a == b
  - structural not equal     # a != b
  - symbolic equality        # Eq(a, b)
  - symbolic not equal       # Ne(a, b)

Constants:
  - pi       # pi
  - eulers number     # E
  - imaginary unity   # I**2 = -1
  - infinity          # oo
  - negative infinity # -oo
  - complex infinity  # zoo
  - not a number      # nan
  - golden ratio      # GoldenRatio

# -------------------------------------------------------------------------
# Rationals

  Rationals:
  - rational object     # Rational(a, b)
  - rational object     # frac = S(a)/b + S(c)/d
  - combines terms      # together(frac)
  - expand terms        # expand(frac)
  - pull the term out   # apart(frac)
  - cancel the terms    # cancel(frac)
  - decimal notation    # N(frac, precission)
  - decimal notation    # (frac).evalf(precision)
  - decimal to fraction # nsimplify(0.25)
  - scientific notation # 1.23e-3

# -------------------------------------------------------------------------
# Complex

Complex:
  - imaginary unity    # I**2 = -1
  - complex number     # z = a + b*I
  - real part          # re(z)
  - imaginary part     # im(z)
  - absolute value     # Abs(z)
  - argument (radians) # arg(z)
  - complex conjugate  # conjugate(z)

Power Complex:
  - power complex                        # exp(z)
  - expand complex trigonometric form    # expanded_z = expand_complex(exp_z)
  - simplify the expanded complex number # simplify(expanded_z)
  - alternate forms                      # expanded_z.rewrite(exp)
  - alternate forms                      # expanded_z.rewrite(exp).factor()
  
# -------------------------------------------------------------------------
# Symbolic Math

Symbolic Workflow:
  - create a symbolic environment  # from sympy import *
  - set latex printing             # init_session()
  - defining a symbolic variables  # x, a, b, c = symbols('x, a, b, c')
  - defining a symbolic expression # expr = a*x**2 + b*x + c
  - evaluate an expression         # expr.subs({a:1, b:2, c:-3})
  - defining a symbolic function   # f = Lambda(x, expr)
  - evaluate at a point            # f(x), f(0), f(-1)
  - defining an symbolic equation  # quadratic_eq = Eq(f(x), 0)
  - solving an symbolic equation   # solutions = solve(quadratic_eq, x)
  - set specific coefficients      # coeffs = {a:1, b:-5, c:6}; roots_.subs(coeffs)
  - find specific solutions        # [sol.subs(coeffs) for sol in solutions]
  - plotting a symbolic function   # plot(f(x).subs(coeffs), (x, -7, 5))

Assumptions:
  - set assumptions           # n = symbols('n', integer=True)
  - assumptions returns       # None, True, False
  - assumption simplification # sqrt(x**2) --> sqrt(x**2), x, |x|
  - multiple assumptions      # x = symbols('x', real=True, negative=False)
  - predicates                # x.assumptions0
  - Check assumptions         # x.is_positive

Symbolic Manipulations:
  - expanding expressions          # expand(factored_expr)
  - factoring expressions          # factor(expanded_expr)
  - cancel common factors          # cancel(expr)
  - combine fractions              # together(combined_expr)
  - partial fraction decomposition # apart(together_expr)
  
Substitutions:
  - replaces instances of a symbol # expr.subs(a, b)
  - evaluate an expr at a point    # expr.subs(x, 0)
  - replace a subexpression        # (expr).subs(sin(2*x), 2*sin(x)*cos(x))
  - multiple substitutions         # expr.subs({a: 1, b: 2, c: -3})

# -------------------------------------------------------------------------
# Solving Equations & Inequalities

Equation Systems:
  - solve linear systems     # linsolve([x + y - 2, 2*x + y - 3], (x, y))
  - solve non-linear systems # nonlinsolve([x**2 + y**2 - 1, x - y], (x, y))
  - solve systems with solve # solve([x + y - 2, 2*x + y - 3], (x, y))

Inequalities:
  - define inequalities # inequality = 3 - x > 2*x + 1
  - solve inequalities  # solve(inequality, x)
  
# -------------------------------------------------------------------------
# Linear Algebra

Matrix Creation:
  - matrix   # M = Matrix([[1, 2], [3, 4]])
  - identity # eye(3)
  - zero     # zeros(2, 3)
  - diagonal # diag(1, 2, 3)

Matrix Operations:
  - basic operations  # A + B, A * B, 3 * A
  - core functions    # A.det(), A.inv(), A.transpose()
  - eigenvalues       # A.eigenvals()
  - eigenvectors      # A.eigenvects()
  - solving (Ax=b)    # A.LUsolve(b), A.solve(b)
  - vector spaces     # A.nullspace(), A.columnspace()
# -------------------------------------------------------------------------
# Calculus

Limits:
  - limit of a function    # limit(f(x), x, a)
  - limit at a singularity # limit(sin(x)/x, x, 0)
  - limit at infinity      # limit(f(x), x, oo)
  - one-sided limity       # limit(f(x), x, 0, '-')

Derivatives:
  - derivative of a function # diff(f(x), x)
  - nth-order derivative     # diff(f(x), x, n)
  - partial derivative       # diff(f(x, y), x)
  - mixed partial derivative # diff(f(x, y), x, y)

Integrals:
  - integral of a function # integrate(f(x), x)
  - unevaluated integral   # Integral(f(x), x)
  - definite integral      # integrate(f(x), (x, a, b))
  - multiple integrals     # integrate(f(x, y), (x, a, b), (y, c, d))

Sequences:
  - infinite sequence      # sequence(n**2)
  - range sequence         # sequence(n**2, (n, 1, 11))
  - get subsequence        # sequence(n**2, (n, 0, oo))[1:n]
  - extract nth term       # sequence(n**2, (n, 0, oo))[n]
  - find linear recurrence # seq.find_linear_recurrence(6)

Advanced:
  - solve differential equations # dsolve(f(x).diff(x, 2) + 9*f(x), f(x))
  - Laplace transform            # LaplaceTransform(f(t), t, s)
  - Laplace transform            # laplace_transform(f(t), t, s)
  - inverse Laplace transform    # inverse_laplace_transform(f(s), s, t)
  - Fourier transform            # FourierTransform(f(x), x, k)
  - Fourier transform            # fourier_transform(f(x), x, k)
  - inverse Fourier transform    # inverse_fourier_transform(f(k), k, x)

# -------------------------------------------------------------------------
# Functions & Plotting

Functions:
  - defining a function # f = Lambda(x, expr)
  - evaluate at a point # f(x)
  - replaces symbols    # f(x).subs(coeffs)

Lambda Functions:
  - define lambda function       # f = Lambda(x, a*x + b)
  - evaluate a lambda function   # Lambda(x, a*x + b)(2) --> 2a + b

Packed Arguments:
  - packed arguments           # args = symbols('a, b')
  - define function            # f = Lambda(args, a + b)
  - evaluate packed arguments  # f(*args) --> a + b

Visualization:
  - symbolic function  # plot(f(x).subs(coeffs), (x, 0, 5))
  - single function    # plot(x**2, (x, -5, 5))
  - multiple functions # plot(sin(x), cos(x), (x, -pi, pi))
  - parametric 2D      # plot_parametric(cos(t), sin(t), (t, 0, 2*pi))
  - 3d surface plots   # plot3d(x*y, (x, -5, 5), (y, -5, 5))
  - parametric 3D      # plot3d_parametric_line(cos(t), sin(t), t, (t, -5, 5))
  - customizing plots  # plot(x**2, title='My Plot', xlabel='x', ylabel='f(x)')

# -------------------------------------------------------------------------
# Intervals & Sets

Creation:
  - symbolic interval   # Interval(a, b)
  - numerical interval  # Interval(0, 1)
  - open interval       # Interval.open(0, 1)
  - right open interval # Interval(0, 1, right_open=True)
  - left open interval  # Interval(0, 1, left_open=True)
  
Compound Intervals:
  - image of the interval # imageset(sin, Interval(0, pi))
  - union                 # A.union(B)
  - intersection          # A.intersect(B)
  - symmetric difference  # A.symmetric_difference(B)
  - complement            # A.complement(B)
  
Interval Elements:
  - start and end points   # A.boundary
  - interior points        # A.interior
  - closure of a interval  # A.closure
  - supremum of a interval # A.sup
  - infimum of a interval  # A.inf

Interval Checks:
  - Check for openness    # A.is_open
  - Check for containment # A.contains(0.5)
  - if no element in common       # A.is_disjoint(B)
  - if is a subset                # A.is_subset(B)
  - if is a superset              # A.is_superset(B)
  - if is a proper subset         # A.is_proper_subset(B)

# -------------------------------------------------------------------------
# Specialized Mathematical Domains

Statistics:
  - random variable         # X = Normal('X', mu, sigma)
  - calculate probability   # P(X > mu)
  - calculate expectation   # E(X)
  - calculate variance      # variance(X)
  - conditional probability # P(X > 0, Die('D') > 4)

Discrete Mathematics:
  - recurrence relation        # rsolve(f(n+2) - f(n+1) - f(n), f(n))
  - specify initial conditions # rsolve(f(n+2) - f(n+1) - f(n), f(n), {f(0): 0, f(1): 1})
  - summation                  # Sum(k,(k, 1, m))
  - product                    # Product(k, (k, 1, n))

Geometry:
  - primitive object         # point = Point(0, 1)
  - one-dimensional objects  # line = Line(p1, p2)
  - angle between two lines  # line1.angle_between(line2)
  regions:
    - triangle               # Triangle(p1, p2, p3)
    - circle                 # Circle(center, radius)
    - ellipse                # Ellipse(center, hradius, vradius, eccentricity)
    - square                 # RegularPolygon(p, 1, 4)
  - area calculation         # region.area

Logical Expressions:
  - standard logical operators   # ~ p | p & q
  - symbolic boolean expressions # (p | q).subs({p: True, q: False})
  - standard logical notation    # Or(Not(p),And(p, q))
  - not logical operators        # Not(p), Nor(p, q), Nand(p, q)
  - exclusive relation           # Exclusive(p, q, x)
  - exclusive logical operators  # Xor(p, q), Xnor(p, q)
  - implies relation             # (p >> q)
  - equivalence relation         # Equivalent(p, q)
  - if-then-else clause          # ITE(x, p, q).subs({x: True})


