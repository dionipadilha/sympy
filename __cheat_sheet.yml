# SymPy Cheat Sheet

# -------------------------------------------------------------------------
# Core Concepts: O "porquê" por trás do SymPy

# Entenda estes conceitos para evitar erros comuns.

# 1. Expressões simbólicas vs. números do Python
# Em Python, `1/2` se torna `0.5`. Para frações exatas, use objetos SymPy.
# Use sympify() ou S() para criá-los: `S(1)/2` permanece como 1/2 (Rational).

# 2. Igualdade simbólica (Eq) vs. igualdade estrutural (==)
# Eq(x, 5): representa a equação matemática "x = 5" (objeto manipulável).
# x == 5: pergunta se o objeto x é estruturalmente idêntico a 5 (True/False).

# 3. Objetos não avaliados (com inicial maiúscula) vs. avaliados (minúscula)
# Integral(f(x), x): cria um objeto não avaliado (útil para manipular ou exibir).
# integrate(f(x), x): tenta calcular o resultado e retorna o valor.

# 4. Assunções são poderosas
# Sem assunções, sqrt(x**2) não pode simplificar pois x pode ser complexo.
# Com `x = symbols('x', real=True)` simplifica para `Abs(x)`.
# Com `x = symbols('x', positive=True)` simplifica para `x`.

# 5. Submódulos especializados
# Funções para estatística, geometria, etc., estão em submódulos.
# Exemplo: `from sympy.stats import Normal, P, E`

# -------------------------------------------------------------------------
# Operações básicas

Aritmética:
  - adição             # a + b
  - subtração          # a - b
  - multiplicação      # a * b
  - potenciação        # a ** b
  - divisão            # a / b
  - divisão inteira    # a // b
  - resto (módulo)     # a % b

Funções matemáticas básicas:
  - quadrado                     # power(x, 2)
  - cubo                         # power(x, 3)
  - potência n-ésima             # power(x, n)
  - exponencial                  # exp(x)
  - logaritmo natural            # log(x)
  - logaritmo base b             # log(x, b)
  - raiz quadrada                # sqrt(x)
  - raiz cúbica                  # root(x, 3)
  - raiz n-ésima                 # root(x, n)
  - valor absoluto simbólico     # Abs(x)

Operadores de comparação:
  - maior que                 # a > b
  - menor que                 # a < b
  - maior ou igual            # a >= b
  - menor ou igual            # a <= b
  - diferente (estrutural)    # a != b
  - igual (estrutural)        # a == b
  - equação simbólica         # Eq(a, b)
  - desigualdade simbólica    # Ne(a, b)

Constantes:
  - pi                  # pi
  - número de Euler     # E
  - unidade imaginária  # I**2 = -1
  - infinito positivo   # oo
  - infinito negativo   # -oo
  - infinito complexo   # zoo
  - não número (NaN)    # nan
  - razão áurea         # GoldenRatio

# -------------------------------------------------------------------------
# Racionais

Racionais:
  - racional simbólico      # Rational(a, b)
  - usando S()              # frac = S(a)/b + S(c)/d
  - combinar termos          # together(frac)
  - expandir termos          # expand(frac)
  - decompor frações         # apart(frac)
  - cancelar termos comuns   # cancel(frac)
  - notação decimal          # N(frac, precision)
  - notação decimal          # frac.evalf(precision)
  - decimal para fração      # nsimplify(0.25)
  - notação científica       # 1.23e-3

# -------------------------------------------------------------------------
# Números complexos

Complexos:
  - unidade imaginária    # I**2 = -1
  - número complexo        # z = a + b*I
  - parte real             # re(z)
  - parte imaginária       # im(z)
  - valor absoluto         # Abs(z)
  - argumento (radianos)   # arg(z)
  - conjugado              # conjugate(z)

Forma exponencial e trigonométrica:
  - exponencial complexa                 # exp(z)
  - expandir forma trigonométrica        # expand_complex(expr)
  - simplificar expressão expandida      # simplify(expr)
  - reescrever em outra forma            # expr.rewrite(exp)
  - fatorar forma alternativa            # expr.rewrite(exp).factor()

# -------------------------------------------------------------------------
# Ambiente simbólico

Uso interativo:
  - importar tudo (notebooks)     # from sympy import *
  - importar com alias (scripts)  # import sympy as sp
  - inicializar sessão simbólica  # init_session()

Em scripts:
  - preferir imports específicos  # from sympy import sin, cos, solve
  - ativar impressão LaTeX        # init_printing()

Definição de símbolos:
  - reais      # x, a, b, c = symbols('x a b c')
  - inteiros   # k, m, n = symbols('k m n', integer=True)
  - funções    # f, g = symbols('f g', cls=Function)

Fluxo simbólico básico:
  - definir expressão simbólica     # expr = a*x**2 + b*x + c
  - substituir valores              # expr.subs({a:1, b:2, c:-3})
  - definir função simbólica        # f = Lambda(x, expr)
  - avaliar em um ponto             # f(0), f(-1)
  - criar equação simbólica         # Eq(f(x), 0)
  - resolver equação simbólica      # solve(Eq(f(x), 0), x)
  - definir coeficientes            # coeffs = {a:1, b:-5, c:6}
  - aplicar coeficientes            # [sol.subs(coeffs) for sol in solutions]
  - plotar função simbólica         # plot(f(x).subs(coeffs), (x, -7, 5))

Assunções:
  - definir assunções           # n = symbols('n', integer=True)
  - verificar assunções         # x.is_positive, x.is_real
  - múltiplas assunções         # x = symbols('x', real=True, positive=True)
  - visualizar assunções        # x.assumptions0
  - simplificação com assunções # sqrt(x**2) → Abs(x) ou x se positivo

Manipulação simbólica:
  - expandir expressões          # expand(expr)
  - fatorar expressões           # factor(expr)
  - cancelar fatores comuns      # cancel(expr)
  - combinar frações             # together(expr)
  - decompor frações parciais    # apart(expr)
  - simplificação geral          # simplify(expr)
  - simplificação trigonométrica # trigsimp(expr)

Substituições:
  - substituir símbolos          # expr.subs(a, b)
  - substituir múltiplos valores # expr.subs({x:1, y:2})
  - substituir subexpressão      # expr.subs(sin(2*x), 2*sin(x)*cos(x))
  - substituição estrutural (rápida) # expr.xreplace({a:b})

# -------------------------------------------------------------------------
# Solução de equações e inequações

Sistemas de equações:
  - sistemas lineares     # linsolve([x + y - 2, 2*x + y - 3], (x, y))
  - sistemas não-lineares # nonlinsolve([x**2 + y**2 - 1, x - y], (x, y))
  - solução geral         # solve([x + y - 2, 2*x + y - 3], (x, y))

Inequações:
  - definir desigualdade   # 3 - x > 2*x + 1
  - resolver desigualdade  # solve(3 - x > 2*x + 1, x)

# -------------------------------------------------------------------------
# Álgebra Linear

Criação de matrizes:
  - matriz      # M = Matrix([[1, 2], [3, 4]])
  - identidade  # eye(3)
  - zero        # zeros(2, 3)
  - diagonal    # diag(1, 2, 3)

Operações:
  - operações básicas   # A + B, A * B, 3*A
  - determinante        # A.det()
  - inversa             # A.inv()
  - transposta          # A.T ou A.transpose()
  - autovalores         # A.eigenvals()
  - autovetores         # A.eigenvects()
  - resolver Ax=b       # A.LUsolve(b), A.solve(b)
  - espaços vetoriais   # A.nullspace(), A.columnspace()

# -------------------------------------------------------------------------
# Cálculo

Limites:
  - limite de função          # limit(f(x), x, a)
  - limite não avaliado       # Limit(f(x), x, a)
  - limite em singularidade   # limit(sin(x)/x, x, 0)
  - limite no infinito        # limit(f(x), x, oo)
  - limite lateral            # limit(f(x), x, 0, '-')

Derivadas:
  - derivada simples          # diff(f(x), x)
  - derivada não avaliada     # Derivative(expr, x)
  - derivada de ordem n       # diff(f(x), x, n)
  - derivada parcial          # diff(f(x, y), x)
  - derivada mista            # diff(f(x, y), x, y)

Integrais:
  - integral indefinida       # integrate(f(x), x)
  - integral não avaliada     # Integral(f(x), x)
  - integral definida          # integrate(f(x), (x, a, b))
  - integrais múltiplas       # integrate(f(x, y), (x, a, b), (y, c, d))

Séries:
  - expansão em série de Taylor # f.series(x, 0, 5)
  - termos de série            # f.series(x, 0, 5).removeO()

Avançado:
  - equações diferenciais       # dsolve(equation, function)
  - transformada de Laplace     # laplace_transform(f(t), t, s)
  - inversa de Laplace          # inverse_laplace_transform(F(s), s, t)
  - transformada de Fourier     # fourier_transform(f(x), x, k)
  - inversa de Fourier          # inverse_fourier_transform(F(k), k, x)

# -------------------------------------------------------------------------
# Funções, Lambdify e Plotagem

Funções simbólicas:
  - definir função simbólica     # f = Lambda(x, expr)
  - avaliar função               # f(x)
  - substituir símbolos           # f(x).subs({a:1, b:2})

Lambda Functions:
  - definir função lambda         # f = Lambda(x, a*x + b)
  - avaliar diretamente           # f(2) -> 2*a + b

Conversão para função numérica:
  - gerar função NumPy/Math       # lambdify(x, expr, 'numpy')
  - exemplo: f = lambdify(x, sin(x)/x, 'numpy')

Visualização:
  - função simbólica             # plot(f(x), (x, 0, 5))
  - múltiplas funções            # plot(sin(x), cos(x), (x, -pi, pi))
  - paramétrica 2D               # plot_parametric(cos(t), sin(t), (t, 0, 2*pi))
  - superfície 3D                # plot3d(x*y, (x, -5, 5), (y, -5, 5))
  - linha paramétrica 3D         # plot3d_parametric_line(cos(t), sin(t), t, (t, -5, 5))
  - personalização               # plot(x**2, title='Meu gráfico', xlabel='x', ylabel='f(x)')

# -------------------------------------------------------------------------
# Intervalos e Conjuntos

Criação:
  - intervalo fechado      # Interval(a, b)
  - intervalo numérico     # Interval(0, 1)
  - intervalo aberto       # Interval.open(0, 1)
  - semiaberto direita     # Interval(0, 1, right_open=True)
  - semiaberto esquerda    # Interval(0, 1, left_open=True)

Operações:
  - imagem de intervalo    # imageset(sin, Interval(0, pi))
  - união                  # A.union(B)
  - interseção             # A.intersect(B)
  - diferença simétrica    # A.symmetric_difference(B)
  - complemento            # A.complement(B)

Propriedades:
  - limites (bordas)       # A.boundary
  - interior                # A.interior
  - fechamento              # A.closure
  - supremo                 # A.sup
  - ínfimo                  # A.inf
  - verificar abertura      # A.is_open
  - verificar inclusão      # A.contains(0.5)
  - disjunção               # A.is_disjoint(B)
  - subconjunto             # A.is_subset(B)
  - superconjunto           # A.is_superset(B)
  - subconjunto próprio     # A.is_proper_subset(B)

# -------------------------------------------------------------------------
# Sequências e Séries Discretas

# SymPy tem suporte simbólico a sequências e séries por meio do módulo:
#   from sympy.series.sequences import Sequence, SeqFormula, RecursiveSeq, SeqPer

# 1. Definição de Sequências

# Sequência genérica:
#   SeqFormula(expr, variable, start, stop=None)

# Exemplo: sequência (n^2) para n = 1, 2, 3, ...
  seq = SeqFormula(n**2, (n, 1, oo))

# Sequência recursiva (definida por recorrência):
  rec = RecursiveSeq(x(n-1) + x(n-2), x(n), n, [0, 1])  # Fibonacci-like

# Sequência periódica (útil para padrões repetitivos):
  periodic = SeqPer([1, 2, 3], n)

# 2. Acesso e manipulação

  seq.term(5)        # retorna o 5º termo (substitui n = 5)
  seq.coeff(n, 2)    # retorna o 2º coeficiente se for série polinomial
  seq[:10]           # primeiros 10 termos (gera lista simbólica)
  list(seq[:10])     # converte para lista Python
  rec[:8]            # primeiros 8 termos da sequência recursiva

# 3. Avaliação e simplificação

  seq.limit         # limite simbólico da sequência quando n → ∞
  seq.diff(n)       # diferença entre termos consecutivos
  seq.simplify()    # simplifica a expressão dos termos

# 4. Conversão em série

  seq.to_series(x)  # gera série formal em x (como somatório)
  seq.sum()         # somatório (Série parcial)
  seq.summation(n)  # equivalente a Sum(seq[n], (n, ...))

# 5. Exemplo prático: Sequência e limite

  seq = SeqFormula(1/n, (n, 1, oo))
  seq.term(5)        # 1/5
  seq.limit          # 0
  seq.sum(1, oo)     # diverge (harmônica)
  seq.simplify()     # retorna 1/n
  seq.to_series(x)   # converte para série formal 1/x + 1/x^2 + ...

# 6. Comparação entre tipos de sequência

| Tipo de sequência | Classe SymPy      | Exemplo básico                 | Uso típico                       |
|-------------------|------------------|--------------------------------|----------------------------------|
| Explícita         | SeqFormula       | n**2                           | Definições diretas               |
| Recursiva         | RecursiveSeq     | a(n) = a(n-1) + a(n-2)         | Recorrências                     |
| Periódica         | SeqPer           | [1, 2, 3, 1, 2, 3, ...]        | Padrões repetitivos              |

# 7. Integração com somatórios e recorrências

  from sympy import Sum, rsolve

  # somatório de sequência explícita
  Sum(seq.formula, (n, 1, m)).doit()

  # resolução de recorrência associada
  rsolve(a(n+1) - 2*a(n), a(n))    # retorna C*2**n

# 8. Dicas e notas práticas

  - `SeqFormula` aceita expressões simbólicas complexas (ex: sin(n*pi/3))
  - `RecursiveSeq` exige condições iniciais explícitas (lista ou dicionário)
  - `SeqPer` é ideal para gerar funções periódicas simbólicas
  - `to_series()` pode ser convertido para série formal com `O(x**n)`
  - `limit_seq(seq.formula, n)` é alternativa útil a `seq.limit`

# -------------------------------------------------------------------------
# Domínios Matemáticos Especializados

Estatística:
  - variável aleatória       # X = Normal('X', mu, sigma)
  - probabilidade             # P(X > mu)
  - esperança (média)         # E(X)
  - variância                 # variance(X)
  - probabilidade condicional # P(X > 0, Die('D') > 4)

Matemática Discreta:
  - recorrência simples       # rsolve(f(n+2) - f(n+1) - f(n), f(n))
  - com condições iniciais     # rsolve(..., {f(0):0, f(1):1})
  - somatório                 # Sum(k, (k, 1, m))
  - produto                   # Product(k, (k, 1, n))

Geometria:
  - ponto                     # Point(0, 1)
  - linha                     # Line(p1, p2)
  - ângulo entre linhas        # line1.angle_between(line2)
  - área de região             # region.area
  Regiões:
    - triângulo               # Triangle(p1, p2, p3)
    - círculo                 # Circle(center, radius)
    - elipse                  # Ellipse(center, hradius, vradius)
    - quadrado                # RegularPolygon(p, 1, 4)

Lógica simbólica:
  - operadores padrão          # ~p | (p & q)
  - expressões booleanas       # (p | q).subs({p: True, q: False})
  - notação simbólica          # Or(Not(p), And(p, q))
  - operadores lógicos         # Not(p), Or(p, q), And(p, q)
  - xor/xnor                   # Xor(p, q), Equivalent(p, q)
  - implicação                 # Implies(p, q)
  - equivalência               # Equivalent(p, q)
  - if-then-else               # ITE(x, p, q).subs({x: True})
